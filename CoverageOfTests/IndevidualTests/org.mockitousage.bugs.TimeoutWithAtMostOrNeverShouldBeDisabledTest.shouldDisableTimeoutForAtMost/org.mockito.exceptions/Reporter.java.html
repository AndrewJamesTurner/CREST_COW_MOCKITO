<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Reporter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito.exceptions</a> &gt; <span class="el_source">Reporter.java</span></div><h1>Reporter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */

package org.mockito.exceptions;

import org.mockito.exceptions.base.MockitoAssertionError;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.internal.exceptions.MockitoLimitations;
import org.mockito.internal.exceptions.VerificationAwareInvocation;
import org.mockito.internal.exceptions.util.ScenarioPrinter;
import org.mockito.internal.junit.JUnitTool;
import org.mockito.internal.matchers.LocalizedMatcher;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.StringJoiner;
import org.mockito.invocation.DescribedInvocation;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.invocation.Location;
import org.mockito.listeners.InvocationListener;
import org.mockito.mock.MockName;
import org.mockito.mock.SerializableMode;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static org.mockito.internal.reporting.Pluralizer.pluralize;
import static org.mockito.internal.util.StringJoiner.join;

/**
 * Reports verification and misusing errors.
 * &lt;p&gt;
 * One of the key points of mocking library is proper verification/exception
 * messages. All messages in one place makes it easier to tune and amend them.
 * &lt;p&gt;
 * Reporter can be injected and therefore is easily testable.
 * &lt;p&gt;
 * Generally, exception messages are full of line breaks to make them easy to
 * read (xunit plugins take only fraction of screen on modern IDEs).
 */
<span class="fc" id="L54">public class Reporter {</span>

    public void checkedExceptionInvalid(Throwable t) {
<span class="nc" id="L57">        throw new MockitoException(join(</span>
                &quot;Checked exception is invalid for this method!&quot;,
                &quot;Invalid: &quot; + t
        ));
    }

    public void cannotStubWithNullThrowable() {
<span class="nc" id="L64">        throw new MockitoException(join(</span>
                &quot;Cannot stub with null throwable!&quot;
        ));

    }

    public void unfinishedStubbing(Location location) {
<span class="nc" id="L71">        throw new UnfinishedStubbingException(join(</span>
                &quot;Unfinished stubbing detected here:&quot;,
                location,
                &quot;&quot;,
                &quot;E.g. thenReturn() may be missing.&quot;,
                &quot;Examples of correct stubbing:&quot;,
                &quot;    when(mock.isOk()).thenReturn(true);&quot;,
                &quot;    when(mock.isOk()).thenThrow(exception);&quot;,
                &quot;    doThrow(exception).when(mock).someVoidMethod();&quot;,
                &quot;Hints:&quot;,
                &quot; 1. missing thenReturn()&quot;,
                &quot; 2. you are trying to stub a final method, you naughty developer!&quot;,
                &quot; 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed&quot;,
                &quot;&quot;
        ));
    }

    public void incorrectUseOfApi() {
<span class="nc" id="L89">        throw new MockitoException(join(</span>
                &quot;Incorrect use of API detected here:&quot;,
                new LocationImpl(),
                &quot;&quot;,
                &quot;You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.&quot;,
                &quot;Examples of correct usage:&quot;,
                &quot;    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);&quot;,
                &quot;    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);&quot;,
                &quot;&quot;
        ));
    }

    public void missingMethodInvocation() {
<span class="nc" id="L102">        throw new MissingMethodInvocationException(join(</span>
                &quot;when() requires an argument which has to be 'a method call on a mock'.&quot;,
                &quot;For example:&quot;,
                &quot;    when(mock.getArticles()).thenReturn(articles);&quot;,
                &quot;&quot;,
                &quot;Also, this error might show up because:&quot;,
                &quot;1. you stub either of: final/private/equals()/hashCode() methods.&quot;,
                &quot;   Those methods *cannot* be stubbed/verified.&quot;,
                &quot;   &quot; + MockitoLimitations.NON_PUBLIC_PARENT,
                &quot;2. inside when() you don't call method on mock but on some other object.&quot;,
                &quot;&quot;
        ));
    }

    public void unfinishedVerificationException(Location location) {
<span class="nc" id="L117">        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(</span>
                &quot;Missing method call for verify(mock) here:&quot;,
                location,
                &quot;&quot;,
                &quot;Example of correct verification:&quot;,
                &quot;    verify(mock).doSomething()&quot;,
                &quot;&quot;,
                &quot;Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.&quot;,
                &quot;Those methods *cannot* be stubbed/verified.&quot;,
                MockitoLimitations.NON_PUBLIC_PARENT,
                &quot;&quot;
        ));

<span class="nc" id="L130">        throw exception;</span>
    }

    public void notAMockPassedToVerify(Class type) {
<span class="nc" id="L134">        throw new NotAMockException(join(</span>
<span class="nc" id="L135">                &quot;Argument passed to verify() is of type &quot; + type.getSimpleName() + &quot; and is not a mock!&quot;,</span>
                &quot;Make sure you place the parenthesis correctly!&quot;,
                &quot;See the examples of correct verifications:&quot;,
                &quot;    verify(mock).someMethod();&quot;,
                &quot;    verify(mock, times(10)).someMethod();&quot;,
                &quot;    verify(mock, atLeastOnce()).someMethod();&quot;
        ));
    }

    public void nullPassedToVerify() {
<span class="nc" id="L145">        throw new NullInsteadOfMockException(join(</span>
                &quot;Argument passed to verify() should be a mock but is null!&quot;,
                &quot;Examples of correct verifications:&quot;,
                &quot;    verify(mock).someMethod();&quot;,
                &quot;    verify(mock, times(10)).someMethod();&quot;,
                &quot;    verify(mock, atLeastOnce()).someMethod();&quot;,
                &quot;    not: verify(mock.someMethod());&quot;,
                &quot;Also, if you use @Mock annotation don't miss initMocks()&quot;
        ));
    }

    public void notAMockPassedToWhenMethod() {
<span class="nc" id="L157">        throw new NotAMockException(join(</span>
                &quot;Argument passed to when() is not a mock!&quot;,
                &quot;Example of correct stubbing:&quot;,
                &quot;    doThrow(new RuntimeException()).when(mock).someMethod();&quot;
        ));
    }

    public void nullPassedToWhenMethod() {
<span class="nc" id="L165">        throw new NullInsteadOfMockException(join(</span>
                &quot;Argument passed to when() is null!&quot;,
                &quot;Example of correct stubbing:&quot;,
                &quot;    doThrow(new RuntimeException()).when(mock).someMethod();&quot;,
                &quot;Also, if you use @Mock annotation don't miss initMocks()&quot;
        ));
    }

    public void mocksHaveToBePassedToVerifyNoMoreInteractions() {
<span class="nc" id="L174">        throw new MockitoException(join(</span>
                &quot;Method requires argument(s)!&quot;,
                &quot;Pass mocks that should be verified, e.g:&quot;,
                &quot;    verifyNoMoreInteractions(mockOne, mockTwo);&quot;,
                &quot;    verifyZeroInteractions(mockOne, mockTwo);&quot;,
                &quot;&quot;
        ));
    }

    public void notAMockPassedToVerifyNoMoreInteractions() {
<span class="nc" id="L184">        throw new NotAMockException(join(</span>
                &quot;Argument(s) passed is not a mock!&quot;,
                &quot;Examples of correct verifications:&quot;,
                &quot;    verifyNoMoreInteractions(mockOne, mockTwo);&quot;,
                &quot;    verifyZeroInteractions(mockOne, mockTwo);&quot;,
                &quot;&quot;
        ));
    }

    public void nullPassedToVerifyNoMoreInteractions() {
<span class="nc" id="L194">        throw new NullInsteadOfMockException(join(</span>
                &quot;Argument(s) passed is null!&quot;,
                &quot;Examples of correct verifications:&quot;,
                &quot;    verifyNoMoreInteractions(mockOne, mockTwo);&quot;,
                &quot;    verifyZeroInteractions(mockOne, mockTwo);&quot;
        ));
    }

    public void notAMockPassedWhenCreatingInOrder() {
<span class="nc" id="L203">        throw new NotAMockException(join(</span>
                &quot;Argument(s) passed is not a mock!&quot;,
                &quot;Pass mocks that require verification in order.&quot;,
                &quot;For example:&quot;,
                &quot;    InOrder inOrder = inOrder(mockOne, mockTwo);&quot;
        ));
    }

    public void nullPassedWhenCreatingInOrder() {
<span class="nc" id="L212">        throw new NullInsteadOfMockException(join(</span>
                &quot;Argument(s) passed is null!&quot;,
                &quot;Pass mocks that require verification in order.&quot;,
                &quot;For example:&quot;,
                &quot;    InOrder inOrder = inOrder(mockOne, mockTwo);&quot;
        ));
    }

    public void mocksHaveToBePassedWhenCreatingInOrder() {
<span class="nc" id="L221">        throw new MockitoException(join(</span>
                &quot;Method requires argument(s)!&quot;,
                &quot;Pass mocks that require verification in order.&quot;,
                &quot;For example:&quot;,
                &quot;    InOrder inOrder = inOrder(mockOne, mockTwo);&quot;
        ));
    }

    public void inOrderRequiresFamiliarMock() {
<span class="nc" id="L230">        throw new MockitoException(join(</span>
                &quot;InOrder can only verify mocks that were passed in during creation of InOrder.&quot;,
                &quot;For example:&quot;,
                &quot;    InOrder inOrder = inOrder(mockOne);&quot;,
                &quot;    inOrder.verify(mockOne).doStuff();&quot;
        ));
    }

    public void invalidUseOfMatchers(int expectedMatchersCount, List&lt;LocalizedMatcher&gt; recordedMatchers) {
<span class="nc" id="L239">        throw new InvalidUseOfMatchersException(join(</span>
                &quot;Invalid use of argument matchers!&quot;,
<span class="nc" id="L241">                expectedMatchersCount + &quot; matchers expected, &quot; + recordedMatchers.size() + &quot; recorded:&quot; +</span>
<span class="nc" id="L242">                        locationsOf(recordedMatchers),</span>
                &quot;&quot;,
                &quot;This exception may occur if matchers are combined with raw values:&quot;,
                &quot;    //incorrect:&quot;,
                &quot;    someMethod(anyObject(), \&quot;raw String\&quot;);&quot;,
                &quot;When using matchers, all arguments have to be provided by matchers.&quot;,
                &quot;For example:&quot;,
                &quot;    //correct:&quot;,
                &quot;    someMethod(anyObject(), eq(\&quot;String by matcher\&quot;));&quot;,
                &quot;&quot;,
                &quot;For more info see javadoc for Matchers class.&quot;,
                &quot;&quot;
        ));
    }

    public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection&lt;LocalizedMatcher&gt; matcherStack) {
<span class="nc" id="L258">        throw new InvalidUseOfMatchersException(join(</span>
                &quot;Invalid use of argument matchers inside additional matcher &quot; + additionalMatcherName + &quot; !&quot;,
                new LocationImpl(),
                &quot;&quot;,
<span class="nc" id="L262">                expectedSubMatchersCount + &quot; sub matchers expected, &quot; + matcherStack.size() + &quot; recorded:&quot;,</span>
<span class="nc" id="L263">                locationsOf(matcherStack),</span>
                &quot;&quot;,
                &quot;This exception may occur if matchers are combined with raw values:&quot;,
                &quot;    //incorrect:&quot;,
                &quot;    someMethod(AdditionalMatchers.and(isNotNull(), \&quot;raw String\&quot;);&quot;,
                &quot;When using matchers, all arguments have to be provided by matchers.&quot;,
                &quot;For example:&quot;,
                &quot;    //correct:&quot;,
                &quot;    someMethod(AdditionalMatchers.and(isNotNull(), eq(\&quot;raw String\&quot;));&quot;,
                &quot;&quot;,
                &quot;For more info see javadoc for Matchers and AdditionalMatchers classes.&quot;,
                &quot;&quot;
        ));
    }

    public void stubPassedToVerify() {
<span class="nc" id="L279">        throw new CannotVerifyStubOnlyMock(join(</span>
                &quot;Argument passed to verify() is a stubOnly() mock, not a full blown mock!&quot;,
                &quot;If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.&quot;
        ));
    }

    public void reportNoSubMatchersFound(String additionalMatcherName) {
<span class="nc" id="L286">        throw new InvalidUseOfMatchersException(join(</span>
                &quot;No matchers found for additional matcher &quot; + additionalMatcherName,
                new LocationImpl(),
                &quot;&quot;
        ));
    }


    private Object locationsOf(Collection&lt;LocalizedMatcher&gt; matchers) {
<span class="nc" id="L295">        List&lt;String&gt; description = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (LocalizedMatcher matcher : matchers)</span>
<span class="nc" id="L297">            description.add(matcher.getLocation().toString());</span>
<span class="nc" id="L298">        return join(description.toArray());</span>
    }

    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {
<span class="nc" id="L302">        String message = join(&quot;Argument(s) are different! Wanted:&quot;,</span>
                wanted,
                new LocationImpl(),
                &quot;Actual invocation has different arguments:&quot;,
                actual,
                actualLocation,
                &quot;&quot;
        );

<span class="nc" id="L311">        throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);</span>
    }

    public void wantedButNotInvoked(DescribedInvocation wanted) {
<span class="nc" id="L315">        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));</span>
    }

    public void wantedButNotInvoked(DescribedInvocation wanted, List&lt;? extends DescribedInvocation&gt; invocations) {
        String allInvocations;
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (invocations.isEmpty()) {</span>
<span class="nc" id="L321">            allInvocations = &quot;Actually, there were zero interactions with this mock.\n&quot;;</span>
        } else {
<span class="nc" id="L323">            StringBuilder sb = new StringBuilder(&quot;\nHowever, there were other interactions with this mock:\n&quot;);</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            for (DescribedInvocation i : invocations) {</span>
<span class="nc" id="L325">                sb.append(i.toString())</span>
<span class="nc" id="L326">                        .append(&quot;\n&quot;)</span>
<span class="nc" id="L327">                        .append(i.getLocation())</span>
<span class="nc" id="L328">                        .append(&quot;\n\n&quot;);</span>
<span class="nc" id="L329">            }</span>
<span class="nc" id="L330">            allInvocations = sb.toString();</span>
        }

<span class="nc" id="L333">        String message = createWantedButNotInvokedMessage(wanted);</span>
<span class="nc" id="L334">        throw new WantedButNotInvoked(message + allInvocations);</span>
    }

    private String createWantedButNotInvokedMessage(DescribedInvocation wanted) {
<span class="nc" id="L338">        return join(</span>
                &quot;Wanted but not invoked:&quot;,
<span class="nc" id="L340">                wanted.toString(),</span>
                new LocationImpl(),
                &quot;&quot;
        );
    }

    public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {
<span class="nc" id="L347">        throw new VerificationInOrderFailure(join(</span>
                &quot;Verification in order failure&quot;,
                &quot;Wanted but not invoked:&quot;,
<span class="nc" id="L350">                wanted.toString(),</span>
                new LocationImpl(),
                &quot;Wanted anywhere AFTER following interaction:&quot;,
<span class="nc" id="L353">                previous.toString(),</span>
<span class="nc" id="L354">                previous.getLocation(),</span>
                &quot;&quot;
        ));
    }

    public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {
<span class="nc" id="L360">        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);</span>
<span class="nc" id="L361">        throw new TooManyActualInvocations(message);</span>
    }

    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,
                                                   Location firstUndesired) {
<span class="nc" id="L366">        return join(</span>
<span class="nc" id="L367">                wanted.toString(),</span>
<span class="nc" id="L368">                &quot;Wanted &quot; + pluralize(wantedCount) + &quot;:&quot;,</span>
                new LocationImpl(),
<span class="nc" id="L370">                &quot;But was &quot; + pluralize(actualCount) + &quot;. Undesired invocation:&quot;,</span>
                firstUndesired,
                &quot;&quot;
        );
    }

    public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {
<span class="nc" id="L377">        throw new NeverWantedButInvoked(join(</span>
<span class="nc" id="L378">                wanted.toString(),</span>
                &quot;Never wanted here:&quot;,
                new LocationImpl(),
                &quot;But invoked here:&quot;,
                firstUndesired,
                &quot;&quot;
        ));
    }

    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {
<span class="nc" id="L388">        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);</span>
<span class="nc" id="L389">        throw new VerificationInOrderFailure(join(</span>
                &quot;Verification in order failure:&quot; + message
        ));
    }

    private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,
                                                     Location lastActualInvocation) {
<span class="nc bnc" id="L396" title="All 2 branches missed.">        String ending =</span>
                (lastActualInvocation != null) ? lastActualInvocation + &quot;\n&quot; : &quot;\n&quot;;

<span class="nc" id="L399">        String message = join(</span>
<span class="nc" id="L400">                wanted.toString(),</span>
<span class="nc" id="L401">                &quot;Wanted &quot; + discrepancy.getPluralizedWantedCount() + &quot;:&quot;,</span>
                new LocationImpl(),
<span class="nc" id="L403">                &quot;But was &quot; + discrepancy.getPluralizedActualCount() + &quot;:&quot;,</span>
                ending
        );
<span class="nc" id="L406">        return message;</span>
    }

    public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {
<span class="nc" id="L410">        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);</span>

<span class="nc" id="L412">        throw new TooLittleActualInvocations(message);</span>
    }

    public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {
<span class="nc" id="L416">        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);</span>

<span class="nc" id="L418">        throw new VerificationInOrderFailure(join(</span>
                &quot;Verification in order failure:&quot; + message
        ));
    }

    public void noMoreInteractionsWanted(Invocation undesired, List&lt;VerificationAwareInvocation&gt; invocations) {
<span class="nc" id="L424">        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();</span>
<span class="nc" id="L425">        String scenario = scenarioPrinter.print(invocations);</span>

<span class="nc" id="L427">        throw new NoInteractionsWanted(join(</span>
                &quot;No interactions wanted here:&quot;,
                new LocationImpl(),
<span class="nc" id="L430">                &quot;But found this interaction on mock '&quot; + safelyGetMockName(undesired.getMock()) + &quot;':&quot;,</span>
<span class="nc" id="L431">                undesired.getLocation(),</span>
                scenario
        ));
    }

    public void noMoreInteractionsWantedInOrder(Invocation undesired) {
<span class="nc" id="L437">        throw new VerificationInOrderFailure(join(</span>
                &quot;No interactions wanted here:&quot;,
                new LocationImpl(),
<span class="nc" id="L440">                &quot;But found this interaction on mock '&quot; + safelyGetMockName(undesired.getMock()) + &quot;':&quot;,</span>
<span class="nc" id="L441">                undesired.getLocation()</span>
        ));
    }

    public void cannotMockClass(Class&lt;?&gt; clazz, String reason) {
<span class="nc" id="L446">        throw new MockitoException(join(</span>
<span class="nc" id="L447">                &quot;Cannot mock/spy &quot; + clazz.toString(),</span>
                &quot;Mockito cannot mock/spy because :&quot;,
                &quot; - &quot; + reason
        ));
    }

    public void cannotStubVoidMethodWithAReturnValue(String methodName) {
<span class="nc" id="L454">        throw new CannotStubVoidMethodWithReturnValue(join(</span>
                &quot;'&quot; + methodName + &quot;' is a *void method* and it *cannot* be stubbed with a *return value*!&quot;,
                &quot;Voids are usually stubbed with Throwables:&quot;,
                &quot;    doThrow(exception).when(mock).someVoidMethod();&quot;,
                &quot;***&quot;,
                &quot;If you're unsure why you're getting above error read on.&quot;,
                &quot;Due to the nature of the syntax above problem might occur because:&quot;,
                &quot;1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.&quot;,
                &quot;2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.&quot;,
                &quot;3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - &quot;,
                &quot;   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.&quot;,
                &quot;4. &quot; + MockitoLimitations.NON_PUBLIC_PARENT,
                &quot;&quot;
        ));
    }

    public void onlyVoidMethodsCanBeSetToDoNothing() {
<span class="nc" id="L471">        throw new MockitoException(join(</span>
                &quot;Only void methods can doNothing()!&quot;,
                &quot;Example of correct use of doNothing():&quot;,
                &quot;    doNothing().&quot;,
                &quot;    doThrow(new RuntimeException())&quot;,
                &quot;    .when(mock).someVoidMethod();&quot;,
                &quot;Above means:&quot;,
                &quot;someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called&quot;
        ));
    }

    public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {
<span class="nc" id="L483">        throw new WrongTypeOfReturnValue(join(</span>
                actualType + &quot; cannot be returned by &quot; + methodName + &quot;()&quot;,
                methodName + &quot;() should return &quot; + expectedType,
                &quot;***&quot;,
                &quot;If you're unsure why you're getting above error read on.&quot;,
                &quot;Due to the nature of the syntax above problem might occur because:&quot;,
                &quot;1. This exception *might* occur in wrongly written multi-threaded tests.&quot;,
                &quot;   Please refer to Mockito FAQ on limitations of concurrency testing.&quot;,
                &quot;2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - &quot;,
                &quot;   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.&quot;,
                &quot;&quot;
        ));
    }

    public void wrongTypeReturnedByDefaultAnswer(Object mock, String expectedType, String actualType, String methodName) {
<span class="nc" id="L498">        throw new WrongTypeOfReturnValue(join(</span>
                &quot;Default answer returned a result with the wrong type:&quot;,
                actualType + &quot; cannot be returned by &quot; + methodName + &quot;()&quot;,
                methodName + &quot;() should return &quot; + expectedType,
                &quot;&quot;,
<span class="nc" id="L503">                &quot;The default answer of &quot; + safelyGetMockName(mock) + &quot; that was configured on the mock is probably incorrectly implemented.&quot;,</span>
                &quot;&quot;
        ));
    }


    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {
<span class="nc" id="L510">        throw new MockitoAssertionError(join(&quot;Wanted at most &quot; + pluralize(maxNumberOfInvocations) + &quot; but was &quot; + foundSize));</span>
    }

    public void misplacedArgumentMatcher(List&lt;LocalizedMatcher&gt; lastMatchers) {
<span class="nc" id="L514">        throw new InvalidUseOfMatchersException(join(</span>
                &quot;Misplaced argument matcher detected here:&quot;,
<span class="nc" id="L516">                locationsOf(lastMatchers),</span>
                &quot;&quot;,
                &quot;You cannot use argument matchers outside of verification or stubbing.&quot;,
                &quot;Examples of correct usage of argument matchers:&quot;,
                &quot;    when(mock.get(anyInt())).thenReturn(null);&quot;,
                &quot;    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());&quot;,
                &quot;    verify(mock).someMethod(contains(\&quot;foo\&quot;))&quot;,
                &quot;&quot;,
                &quot;Also, this error might show up because you use argument matchers with methods that cannot be mocked.&quot;,
                &quot;Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().&quot;,
                MockitoLimitations.NON_PUBLIC_PARENT,
                &quot;&quot;
        ));
    }

    public void smartNullPointerException(String invocation, Location location) {
<span class="nc" id="L532">        throw new SmartNullPointerException(join(</span>
                &quot;You have a NullPointerException here:&quot;,
                new LocationImpl(),
                &quot;because this method call was *not* stubbed correctly:&quot;,
                location,
                invocation,
                &quot;&quot;
        ));
    }

    public void noArgumentValueWasCaptured() {
<span class="nc" id="L543">        throw new MockitoException(join(</span>
                &quot;No argument value was captured!&quot;,
                &quot;You might have forgotten to use argument.capture() in verify()...&quot;,
                &quot;...or you used capture() in stubbing but stubbed method was not called.&quot;,
                &quot;Be aware that it is recommended to use capture() only with verify()&quot;,
                &quot;&quot;,
                &quot;Examples of correct argument capturing:&quot;,
                &quot;    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);&quot;,
                &quot;    verify(mock).doSomething(argument.capture());&quot;,
                &quot;    assertEquals(\&quot;John\&quot;, argument.getValue().getName());&quot;,
                &quot;&quot;
        ));
    }

    public void extraInterfacesDoesNotAcceptNullParameters() {
<span class="nc" id="L558">        throw new MockitoException(join(</span>
                &quot;extraInterfaces() does not accept null parameters.&quot;
        ));
    }

    public void extraInterfacesAcceptsOnlyInterfaces(Class&lt;?&gt; wrongType) {
<span class="nc" id="L564">        throw new MockitoException(join(</span>
                &quot;extraInterfaces() accepts only interfaces.&quot;,
<span class="nc" id="L566">                &quot;You passed following type: &quot; + wrongType.getSimpleName() + &quot; which is not an interface.&quot;</span>
        ));
    }

    public void extraInterfacesCannotContainMockedType(Class&lt;?&gt; wrongType) {
<span class="nc" id="L571">        throw new MockitoException(join(</span>
                &quot;extraInterfaces() does not accept the same type as the mocked type.&quot;,
<span class="nc" id="L573">                &quot;You mocked following type: &quot; + wrongType.getSimpleName(),</span>
                &quot;and you passed the same very interface to the extraInterfaces()&quot;
        ));
    }

    public void extraInterfacesRequiresAtLeastOneInterface() {
<span class="nc" id="L579">        throw new MockitoException(join(</span>
                &quot;extraInterfaces() requires at least one interface.&quot;
        ));
    }

    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class&lt;?&gt; mockedType, Object spiedInstance) {
<span class="nc" id="L585">        throw new MockitoException(join(</span>
                &quot;Mocked type must be the same as the type of your spied instance.&quot;,
<span class="nc" id="L587">                &quot;Mocked type must be: &quot; + spiedInstance.getClass().getSimpleName() + &quot;, but is: &quot; + mockedType.getSimpleName(),</span>
                &quot;  //correct spying:&quot;,
                &quot;  spy = mock( -&gt;ArrayList.class&lt;- , withSettings().spiedInstance( -&gt;new ArrayList()&lt;- );&quot;,
                &quot;  //incorrect - types don't match:&quot;,
                &quot;  spy = mock( -&gt;List.class&lt;- , withSettings().spiedInstance( -&gt;new ArrayList()&lt;- );&quot;
        ));
    }

    public void cannotCallAbstractRealMethod() {
<span class="nc" id="L596">        throw new MockitoException(join(</span>
                &quot;Cannot call abstract real method on java object!&quot;,
                &quot;Calling real methods is only possible when mocking non abstract method.&quot;,
                &quot;  //correct example:&quot;,
                &quot;  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();&quot;
        ));
    }

    public void cannotVerifyToString() {
<span class="nc" id="L605">        throw new MockitoException(join(</span>
                &quot;Mockito cannot verify toString()&quot;,
                &quot;toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). &quot; +
                        &quot;Verifying it may give inconsistent or hard to understand results. &quot; +
                        &quot;Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)&quot;,
                &quot;However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.&quot;
        ));
    }

    public void moreThanOneAnnotationNotAllowed(String fieldName) {
<span class="nc" id="L615">        throw new MockitoException(&quot;You cannot have more than one Mockito annotation on a field!\n&quot; +</span>
                &quot;The field '&quot; + fieldName + &quot;' has multiple Mockito annotations.\n&quot; +
                &quot;For info how to use annotations see examples in javadoc for MockitoAnnotations class.&quot;);
    }

    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {
<span class="nc" id="L621">        throw new MockitoException(&quot;This combination of annotations is not permitted on a single field:\n&quot; +</span>
                &quot;@&quot; + undesiredAnnotationOne + &quot; and @&quot; + undesiredAnnotationTwo);
    }

    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {
<span class="nc" id="L626">        throw new MockitoException(join(&quot;Cannot instantiate a @Spy for '&quot; + fieldName + &quot;' field.&quot;,</span>
                &quot;You haven't provided the instance for spying at field declaration so I tried to construct the instance.&quot;,
<span class="nc" id="L628">                &quot;However, I failed because: &quot; + details.getMessage(),</span>
                &quot;Examples of correct usage of @Spy:&quot;,
                &quot;   @Spy List mock = new LinkedList();&quot;,
                &quot;   @Spy Foo foo; //only if Foo has parameterless constructor&quot;,
                &quot;   //also, don't forget about MockitoAnnotations.initMocks();&quot;,
                &quot;&quot;), details);
    }

    public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {
<span class="nc" id="L637">        throw new MockitoException(join(&quot;Cannot instantiate @InjectMocks field named '&quot; + fieldName + &quot;'.&quot;,</span>
                &quot;You haven't provided the instance at field declaration so I tried to construct the instance.&quot;,
<span class="nc" id="L639">                &quot;However, I failed because: &quot; + details.getMessage(),</span>
                &quot;Examples of correct usage of @InjectMocks:&quot;,
                &quot;   @InjectMocks Service service = new Service();&quot;,
                &quot;   @InjectMocks Service service;&quot;,
                &quot;   //also, don't forget about MockitoAnnotations.initMocks();&quot;,
                &quot;   //and... don't forget about some @Mocks for injection :)&quot;,
                &quot;&quot;), details);
    }

    public void atMostAndNeverShouldNotBeUsedWithTimeout() {
<span class="fc" id="L649">        throw new FriendlyReminderException(join(&quot;&quot;,</span>
                &quot;Don't panic! I'm just a friendly reminder!&quot;,
                &quot;timeout() should not be used with atMost() or never() because...&quot;,
                &quot;...it does not make much sense - the test would have passed immediately in concurency&quot;,
                &quot;We kept this method only to avoid compilation errors when upgrading Mockito.&quot;,
                &quot;In future release we will remove timeout(x).atMost(y) from the API.&quot;,
                &quot;If you want to find out more please refer to issue 235&quot;,
                &quot;&quot;));
    }

    public void fieldInitialisationThrewException(Field field, Throwable details) {
<span class="nc" id="L660">        throw new MockitoException(join(</span>
<span class="nc" id="L661">                &quot;Cannot instantiate @InjectMocks field named '&quot; + field.getName() + &quot;' of type '&quot; + field.getType() + &quot;'.&quot;,</span>
                &quot;You haven't provided the instance at field declaration so I tried to construct the instance.&quot;,
<span class="nc" id="L663">                &quot;However the constructor or the initialization block threw an exception : &quot; + details.getMessage(),</span>
                &quot;&quot;), details);

    }

    public void invocationListenerDoesNotAcceptNullParameters() {
<span class="nc" id="L669">        throw new MockitoException(&quot;invocationListeners() does not accept null parameters&quot;);</span>
    }

    public void invocationListenersRequiresAtLeastOneListener() {
<span class="nc" id="L673">        throw new MockitoException(&quot;invocationListeners() requires at least one listener&quot;);</span>
    }

    public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {
<span class="nc" id="L677">        throw new MockitoException(StringJoiner.join(</span>
<span class="nc" id="L678">                &quot;The invocation listener with type &quot; + listener.getClass().getName(),</span>
<span class="nc" id="L679">                &quot;threw an exception : &quot; + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);</span>
    }

    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
<span class="nc" id="L683">        throw new MockitoException(join(</span>
<span class="nc" id="L684">                &quot;Mockito couldn't inject mock dependency '&quot; + safelyGetMockName(matchingMock) + &quot;' on field &quot;,</span>
                &quot;'&quot; + field + &quot;'&quot;,
<span class="nc" id="L686">                &quot;whose type '&quot; + field.getDeclaringClass().getCanonicalName() + &quot;' was annotated by @InjectMocks in your test.&quot;,</span>
<span class="nc" id="L687">                &quot;Also I failed because: &quot; + exceptionCauseMessageIfAvailable(details),</span>
                &quot;&quot;
        ), details);
    }

    private String exceptionCauseMessageIfAvailable(Exception details) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (details.getCause() == null) {</span>
<span class="nc" id="L694">            return details.getMessage();</span>
        }
<span class="nc" id="L696">        return details.getCause().getMessage();</span>
    }

    public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
<span class="nc" id="L700">        throw new MockitoException(join(</span>
                &quot;Mocked type must be the same as the type of your delegated instance.&quot;,
<span class="nc" id="L702">                &quot;Mocked type must be: &quot; + delegatedInstance.getClass().getSimpleName() + &quot;, but is: &quot; + mockedType.getSimpleName(),</span>
                &quot;  //correct delegate:&quot;,
                &quot;  spy = mock( -&gt;List.class&lt;- , withSettings().delegatedInstance( -&gt;new ArrayList()&lt;- );&quot;,
                &quot;  //incorrect - types don't match:&quot;,
                &quot;  spy = mock( -&gt;List.class&lt;- , withSettings().delegatedInstance( -&gt;new HashSet()&lt;- );&quot;
        ));
    }

    public void spyAndDelegateAreMutuallyExclusive() {
<span class="nc" id="L711">        throw new MockitoException(join(</span>
                &quot;Settings should not define a spy instance and a delegated instance at the same time.&quot;
        ));
    }

    public void invalidArgumentRangeAtIdentityAnswerCreationTime() {
<span class="nc" id="L717">        throw new MockitoException(join(&quot;Invalid argument index.&quot;,</span>
                &quot;The index need to be a positive number that indicates the position of the argument to return.&quot;,
                &quot;However it is possible to use the -1 value to indicates that the last argument should be&quot;,
                &quot;returned.&quot;));
    }

    public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {
<span class="nc" id="L724">        throw new MockitoException(</span>
<span class="nc" id="L725">                join(&quot;Invalid argument index for the current invocation of method : &quot;,</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                        &quot; -&gt; &quot; + safelyGetMockName(invocation.getMock()) + &quot;.&quot; + invocation.getMethod().getName() + &quot;()&quot;,</span>
                        &quot;&quot;,
                        (willReturnLastParameter ?
                                &quot;Last parameter wanted&quot; :
<span class="nc" id="L730">                                &quot;Wanted parameter at position &quot; + argumentIndex) + &quot; but &quot; + possibleArgumentTypesOf(invocation),</span>
                        &quot;The index need to be a positive number that indicates a valid position of the argument in the invocation.&quot;,
                        &quot;However it is possible to use the -1 value to indicates that the last argument should be returned.&quot;,
                        &quot;&quot;));
    }

    private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {
<span class="nc" id="L737">        Class&lt;?&gt;[] parameterTypes = invocation.getMethod().getParameterTypes();</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (parameterTypes.length == 0) {</span>
<span class="nc" id="L739">            return new StringBuilder(&quot;the method has no arguments.\n&quot;);</span>
        }

<span class="nc" id="L742">        StringBuilder stringBuilder = new StringBuilder(&quot;the possible argument indexes for this method are :\n&quot;);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        for (int i = 0, parameterTypesLength = parameterTypes.length; i &lt; parameterTypesLength; i++) {</span>
<span class="nc" id="L744">            stringBuilder.append(&quot;    [&quot;).append(i);</span>

<span class="nc bnc" id="L746" title="All 4 branches missed.">            if (invocation.getMethod().isVarArgs() &amp;&amp; i == parameterTypesLength - 1) {</span>
<span class="nc" id="L747">                stringBuilder.append(&quot;+] &quot;).append(parameterTypes[i].getComponentType().getSimpleName()).append(&quot;  &lt;- Vararg&quot;).append(&quot;\n&quot;);</span>
            } else {
<span class="nc" id="L749">                stringBuilder.append(&quot;] &quot;).append(parameterTypes[i].getSimpleName()).append(&quot;\n&quot;);</span>
            }
        }
<span class="nc" id="L752">        return stringBuilder;</span>
    }

    public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {
<span class="nc" id="L756">        throw new WrongTypeOfReturnValue(join(</span>
<span class="nc" id="L757">                &quot;The argument of type '&quot; + actualType.getSimpleName() + &quot;' cannot be returned because the following &quot;,</span>
                &quot;method should return the type '&quot; + expectedType + &quot;'&quot;,
<span class="nc" id="L759">                &quot; -&gt; &quot; + safelyGetMockName(invocation.getMock()) + &quot;.&quot; + invocation.getMethod().getName() + &quot;()&quot;,</span>
                &quot;&quot;,
                &quot;The reason for this error can be :&quot;,
                &quot;1. The wanted argument position is incorrect.&quot;,
                &quot;2. The answer is used on the wrong interaction.&quot;,
                &quot;&quot;,
<span class="nc" id="L765">                &quot;Position of the wanted argument is &quot; + argumentIndex + &quot; and &quot; + possibleArgumentTypesOf(invocation),</span>
                &quot;***&quot;,
                &quot;However if you're still unsure why you're getting above error read on.&quot;,
                &quot;Due to the nature of the syntax above problem might occur because:&quot;,
                &quot;1. This exception *might* occur in wrongly written multi-threaded tests.&quot;,
                &quot;   Please refer to Mockito FAQ on limitations of concurrency testing.&quot;,
                &quot;2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - &quot;,
                &quot;   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.&quot;,
                &quot;&quot;
        ));
    }

    public void defaultAnswerDoesNotAcceptNullParameter() {
<span class="nc" id="L778">        throw new MockitoException(&quot;defaultAnswer() does not accept null parameter&quot;);</span>
    }

    public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {
<span class="nc" id="L782">        throw new MockitoException(join(</span>
<span class="nc" id="L783">                &quot;You are using the setting 'withSettings().serializable()' however the type you are trying to mock '&quot; + classToMock.getSimpleName() + &quot;'&quot;,</span>
                &quot;do not implement Serializable AND do not have a no-arg constructor.&quot;,
                &quot;This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized&quot;,
                &quot;&quot;,
                &quot;Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,&quot;,
                &quot;i.e. the top-most superclass has to implements Serializable.&quot;,
                &quot;&quot;
        ));
    }

    public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
<span class="nc" id="L794">        throw new MockitoException(join(</span>
                &quot;Methods called on delegated instance must have compatible return types with the mock.&quot;,
<span class="nc" id="L796">                &quot;When calling: &quot; + mockMethod + &quot; on mock: &quot; + safelyGetMockName(mock),</span>
<span class="nc" id="L797">                &quot;return type should be: &quot; + mockMethod.getReturnType().getSimpleName() + &quot;, but was: &quot; + delegateMethod.getReturnType().getSimpleName(),</span>
                &quot;Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods&quot;,
<span class="nc" id="L799">                &quot;(delegate instance had type: &quot; + delegate.getClass().getSimpleName() + &quot;)&quot;</span>
        ));
    }

    public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
<span class="nc" id="L804">        throw new MockitoException(join(</span>
                &quot;Methods called on mock must exist in delegated instance.&quot;,
<span class="nc" id="L806">                &quot;When calling: &quot; + mockMethod + &quot; on mock: &quot; + safelyGetMockName(mock),</span>
                &quot;no such method was found.&quot;,
                &quot;Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods&quot;,
<span class="nc" id="L809">                &quot;(delegate instance had type: &quot; + delegate.getClass().getSimpleName() + &quot;)&quot;</span>
        ));
    }

    public void usingConstructorWithFancySerializable(SerializableMode mode) {
<span class="nc" id="L814">        throw new MockitoException(&quot;Mocks instantiated with constructor cannot be combined with &quot; + mode + &quot; serialization mode.&quot;);</span>
    }

    public void cannotCreateTimerWithNegativeDurationTime(long durationMillis) {
<span class="nc" id="L818">        throw new FriendlyReminderException(join(&quot;&quot;,</span>
                &quot;Don't panic! I'm just a friendly reminder!&quot;,
                &quot;It is impossible for time to go backward, therefore...&quot;,
                &quot;You cannot put negative value of duration: (&quot; +  durationMillis +  &quot;)&quot;,
                &quot;as argument of timer methods (after(), timeout())&quot;,
                &quot;&quot;));
    }

    public void notAnException() {
<span class="nc" id="L827">        throw new MockitoException(join(</span>
                &quot;Exception type cannot be null.&quot;,
                &quot;This may happen with doThrow(Class)|thenThrow(Class) family of methods if passing null parameter.&quot;));
    }

    private MockName safelyGetMockName(Object mock) {
<span class="nc" id="L833">        return new MockUtil().getMockName(mock);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>